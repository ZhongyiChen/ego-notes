## 指令系统
> 指令按功能分为 8 类：数据传送指令、算术运算指令、逻辑运算指令、移位指令、字符串操作指令、程序控制指令、系统功能调用指令、处理器控制指令。


### 数据传送指令


1. 传送指令 **MOV**

传送指令相当于高级语言的赋值语句。
指令格式：

`MOV 目标操作数,源操作数`

或者：

`MOV register/memery,register/memery/immediate`

对 MOV 指令的要求如下：
* 两个操作数的字长必须相同。
* 不能再存储器之间直接传送数据，即两个操作数不能同时是地址。
* 目标操作数不能是寄存器 IP、CS，即不能直接修改 IP、CS。
* 立即数不能直接传给段寄存器。
* 两个操作数不能同时是段寄存器。

执行 MOV 指令后，改变目标操作数，不改变源操作数。


2. 交换指令 **XCHG**

该指令的功能是互换两个操作数，即目标操作数变成源操作数，源操作数变成目标操作数。
指令格式：

`MOV 目标操作数,源操作数`

该指令的目标操作数可以是通用寄存器，源操作数可以是通用寄存器或存储器的有效地址。可以在两个寄存器之间或寄存器和存储器之间交换数据，要求被交换的两个操作数的数据类型一致。


3. 有效地址传送指令 **LEA**

其功能是将存储器的有效地址(偏移地址)送入寄存器(通常是 BX、DX、DI 或 SI)。
指令格式：

`LEA 寄存器,存储器的有效地址`

假设有一个符号 buffer 指向指令段内嵌入的某个数据字，而该字的偏移地址为 0006H，而其内容为 1234H。则有：

```asm
; 在 NASM 中，buffer 就相当于一个立即数
; 在 MASM 中，buffer 则相当于存储地址
; 由于本人学的是 NASM ，因此代码结果如下

mov ax,cs
mov ds,ax
                    ; LEA 指令的源操作数不能是立即数
lea dx,buffer       ; ERROR!!!
lea dx,[buffer]     ; DX = 0006H
mov dx,buffer       ; DX = 0006H
mov dx,[buffer]     ; DX = 1234H
```


4. 栈的操作指令

栈是内存的一种逻辑段。即它是由指令系统利用内存构造出来的一段特殊空间，用于存储一些临时数据。


1). 数据进栈指令 **PUSH**

将数据存入栈。
指令格式：

`PUSH 寄存器/存储器的有效地址`

或者在 80286 及其之后的指令格式：

`PUSH 寄存器/存储器的有效地址/常数`

执行 PUSH 之前，栈顶指针 SP 自动减去相应的字节长度(在实模式下是2)，然后，处理器将操作数存放到 SS:SP 指向的内存中。


2). 数据出栈指令 **POP**

将数据从栈中弹出。
指令格式：

`POP 寄存器/存储器的有效地址`

处理器将栈顶 SS:SP 的数据移到操作数中。执行 POP 之后，栈顶指针 SP 自动加上相应的字节长度(在实模式下是2)。


5. 输入输出指令

8086 及以后的处理器通过输入输出指令实现外设与处理器的数据传送。


1). 输入指令 **IN**

该指令可把某个输入端口的数据送到指定累加器(AL/AX/EAX/RAX)。IN 是指送入处理器。指令格式：

`IN AL,端口地址`

`IN AX,端口地址`

`IN EAX,端口地址`

微机最多给外设分配了 64K 个端口，前 256 个端口(0~FFH)称为固定端口，可直接在 IN 或 OUT 指令中给出，称为端口直接寻址。大于 255 的端口地址(超过 8 位)称为可变端口，首先把端口地址送 DX 寄存器，即采用端口间接寻址，然后用 IN、OUT 指令传送信息。

```asm
; 直接给出小于 255 的端口地址
in ax,128

; 大于 255 的端口地址需存入 DX
mov dx,0x3ff
in al,dx
```


2). 输出指令 **OUT**

该指令可把累加器(AL/AX/EAX/RAX)数据传送到某个输出端口。OUT 是指从处理器中送出。指令格式：

`OUT 端口地址,AL`

`OUT 端口地址,AX`

`OUT 端口地址,EAX`

IN、OUT 指令的端口地址可采用直接寻址、间接寻址方式。


### 算术运算指令


1. 加法指令


1). 不带进位加法指令 **ADD**

该指令的功能是两个操作数相加，结果放在被加数中。指令格式：

`ADD 被加数,加数`

加数可以是通用寄存器、存储器的有效地址或立即数(常数)；被加数可以是通用寄存器或存储器的有效地址。但是，两个操作数不能同时是地址。ADD 指令影响标志位 AF、CF、OF、PF、SF、ZF 。


2). 带进位加法指令 **ADC**

该指令的功能是 3 个数相加，结果放在被加数中。即 "被加数 + 加数 + CF -> 被加数" (其中 CF 是进位标志)。除了需要加上 CF 外，其他的，跟指令 ADD 一致。


3). 加 1 指令 **INC**

该指令的功能是被加数加 1。指令格式：

`INC 被加数`

被加数可以是通用寄存器或存储器的有效地址。INC 指令常用于修改地址指针(BX、BP、SI、DI)，使之指向下一个单元。该指令影响标志位 AF、OF、PF、SF、ZF，但不影响标志位 CF。


2. 减法指令


1). 借位标志不参与运算的减法指令 **SUB**

该指令的功能是两个操作数相减，结果放在被减数中。指令格式：

`SUB 被减数,减数`

减数可以是通用寄存器、存储器的有效地址或立即数(常数)；被减数可以是通用寄存器或存储器的有效地址。但是，两个操作数不能同时是地址。SUB 指令影响标志位 AF、CF、OF、PF、SF、ZF 。


2). 借位标志参与运算的减法指令 **SBB**

该指令的功能是 "被减数 - 减数 - CF -> 被减数"。除了需要减去 CF 外，其他情况跟指令 SUB 一致。


3). 减 1 指令 **DEC**

该指令的功能是被减数减 1。指令格式：

`DEC 被减数`

被减数可以是通用寄存器或存储器的有效地址。DEC 指令常用于修改计数值，控制循环次数。该指令影响标志位 AF、OF、PF、SF、ZF，但不影响标志位 CF。


4). 求补指令 **NEG**

该指令的功能是对操作数的每位取反值，末位再加 1。指令格式：

`NEG 操作数`

操作数可以是通用寄存器或存储器的有效地址。NEG 指令影响标志位 AF、CF、OF、PF、SF、ZF 。

```asm
; NEG 指令可用于改变操作数的正负号
mov al,-7   ; AL = -7
neg al      ; AL = +7
```


5). 比较指令 **CMP**

该指令用于比较两数的大小，从而为条件转移指令提供转移条件。CMP 指令相当于执行减法操作，其结果影响标志位，但不影响操作数。

执行 CMP 指令后，判别两数比较结果的法则如下：

* 两个无符号数的比较结果由标志位 CF 或 ZF 决定。如执行 "CMP AX,BX" 指令。
  * 若 AX-BX 没有借位(CF=0)，则表示 AX > BX。
  * 若 AX-BX 有借位(CF=1)，则表示 AX < BX。
  * 若 ZF=1(AX-BX=0)，则表示 AX = BX。

* 两个有符号数的比较结果由 ZF 决定或由 OF、SF 共同决定。如执行 "CMP AX,BX" 指令。
  * 若 ZF=1(AX-BX=0)，则表示 AX = BX。
  * 若 OF、SF 相同，则表示 AX > BX。
  * 若 OF、SF 不同，则表示 AX < BX。


3. 乘法指令


1). 无符号数的乘法指令 **MUL**

该指令的功能如表格所示：

| 乘数位数 | 操作 | 乘积 |
|-|-|-|
| MUL 8位乘数 | AL × 8位乘数 -> AX | 乘积送入 AX 寄存器 |
| MUL 16位乘数 | AX × 16位乘数 -> DX:AX | 乘积的高16位送入 DX，低16位送入 AX |
| MUL 32位乘数 | EAX × 32位乘数 -> EDX:EAX | 乘积的高32位送入 EDX，低32位送入 EAX |

指令格式：

`MUL 无符号乘数`

对于无符号乘法，相关的说明如下：<br>
(1) 乘数存储在寄存器或存储单元中，不能是立即数。<br>
(2) 乘数、被乘数的位数必须相同。<br>
(3) 操作数必须有确定类型，当存储器寻址方式不能确定类型时，必须用伪指令说明类型。<br>
(4) MUL 指令影响标志位 CF、OF。若乘积的高位部分(字节乘法是 AH，字乘法是 DX，双字乘法是 EDX)不是 0，即 AH、DX 或 EDX 包含乘积数据，则有 CF=OF=1，否则 CF=OF=0。<br>


2). 有符号数的乘法指令 IMUL

IMUL 指令用于符号数的乘法，乘数、被乘数都是符号数。指令格式：

`IMUL 带符号的乘数`

执行指令后，若乘积的高一半是低一半的符号扩展，则 OF=CF=1，否则 OF=CF=0。


4. 除法指令

除法指令有两种：无符号数除法指令 DIV、有符号数除法指令 IDIV。指令格式：

`DIV 无符号除数`

或

`IDIV 有符号除数`

除法指令的规定如表格所示：

| 除数位数 | 操作 | 结果 |
|-|-|-|
| 8位除数 | AX ÷ 8位除数 | 8位商 -> AL，8位余数 -> AH |
| 16位除数 | DX:AX ÷ 16位除数 | 16位商 -> AX，16位余数 -> DX |
| 32位除数 | EDX:EAX ÷ 32位除数 | 32位商 -> EAX，32位余数 -> EDX |

对于除法指令，相关的说明如下：<br>
(1) 除数在寄存器或存储单元中，不能是立即数。<br>
(2) 被除数应是除数的双倍字长，如除数是 8 位，则被除数应是 16 位。<br>
(3) 操作数必须有确定的类型，当存储器寻址方式不能确定类型时，须用伪指令予以说明。<br>
(4) 除法指令不影响标志位。


### 逻辑运算指令
逻辑运算指令以二进制位作为运算单位。


1. 逻辑与指令 **AND**

逻辑与也叫逻辑乘。该指令可使二进制数的某些位是 0，其他位不变。指令格式：

`AND 目标操作数,源操作数`


2. 逻辑或指令 **OR**

逻辑或也叫逻辑加。该指令可使二进制数的某些位是 1，其他位不变。指令格式：

`OR 目标操作数,源操作数`


3. 逻辑非指令 **NOT**

逻辑非也叫逻辑反。该指令可使二进制数的每位取反。操作数不能是立即数，指令不影响标志位。指令格式：

`NOT 操作数`


4. 逻辑异或指令 **XOR**

该指令的功能是两个操作数按二进制位做逻辑异或运算————对应位的数据相同时，该位的结果为 0，否则为 1。XOR 指令可用于某些位取反值。指令格式：

`OR 目标操作数,源操作数`


5. 测试指令 **TEST**

该指令的功能是两个操作数做逻辑与运算，运算结果不影响操作数，只影响标志位。TEST 指令常用于测试某位是 1，还是 0。指令格式：

`TEST 目标操作数,源操作数`


### 移位指令


1. 逻辑移位指令

> 逻辑移位指令用于无符号数的移位。

| 指令格式 | 指令名称 |
|-|-|
| SHL 操作数,左移次数 | 逻辑左移 |
| SHR 操作数,右移次数 | 逻辑右移 |

注意事项：<br>
(1) SHL、SHR 两指令只是数据移动的方向不同。<br>
(2) 逻辑移位指令移出的位依次送入标志位 CF，空出的位补 0。<br>
(3) 移位次数可在指令中直接给出，或由 CL 寄存器指定。<br>
(4) 逻辑移位指令影响标志位 CF、OF、PF、SF、ZF。<br>
(5) 逻辑左移指令可用于无符号数的简单乘法运算。逻辑右移指令可用于无符号数的简单除法运算<br>


2. 算术移位指令

> 算术移位指令用于有符号数的移位。

| 指令格式 | 指令名称 |
|-|-|
| SAL 操作数,左移次数 | 算术左移 |
| SAR 操作数,右移次数 | 算术右移 |

注意事项：<br>
(1) SAL 与 SHL 的功能完全相同。<br>
(2) 移位次数可在指令中直接给出，或由 CL 寄存器指定。<br>
(3) SAR 指令是操作数的高位向低位移动，最低位移入 CF，空出的高位用原数最高位(符号位)填补，即数据算术右移后符号位不变。
(4) 算术移位指令影响标志位 CF、OF、PF、SF、ZF。<br>
(5) 算术移位指令可用于有符号数的简单乘除法运算。<br>


3. 循环移位指令

| 指令格式 | 指令名称 |
|-|-|
| ROL 操作数,左移次数 | 循环左移 |
| ROR 操作数,右移次数 | 循环右移 |

注意事项：<br>
(1) ROL 与 ROR 两指令只是数据移位的方向不同。<br>
(2) 移位次数可在指令中直接给出，或由 CL 寄存器指定。<br>
(3) 循环移位指令移出的位同时送入 CF 和空位。<br>
(4) 循环移位指令影响标志位 CF、OF。<br>


4. 带进位标志的循环移位指令

| 指令格式 | 指令名称 |
|-|-|
| RCL 操作数,左移次数 | 带进位标志的循环左移 |
| RCR 操作数,右移次数 | 带进位标志的循环右移 |

注意事项：<br>
(1) RCL、RCR 两指令只是数据移位的方向不同。<br>
(2) 移位次数可在指令中直接给出，或由 CL 寄存器指定。<br>
(3) 带进位标志的循环移位指令移位时，用 CF 填补空位，移出的位送入 CF。<br>
(4) 带进位标志的循环移位指令影响标志位 CF、OF。<br>
(5) 循环移位指令可用于————测试某些位是 1，还是 0；交换数据高位部分和地位部分；与非循环移位指令结合实现 32 位或更多位数据的移位。


### 字符串操作指令
> 字符串操作指令简称串操作指令，包括 传送串(MOVS)、比较串(CMPS)、扫描串(SCAS)、装入串(LODS)、存储串(STOS)、输入串(INS)、输出串(OUTS) 指令。

* 串操作指令用于处理一片连续存储单元的数据。

* 常在串操作指令前加上重复前缀 REP 或条件重复前缀，以便传送串指令自动反复指向：

| 指令格式 | 指令功能 |
|-|-|
| REP 串指令 | 反复执行串操作指令，直到 CX=0 才结束 |
| REPE 串指令 | 相等重复。即当 CX≠0 且 ZF=1 时，重复串指令 |
| REPZ 串指令 | 零重复。条件和 REPE 一样 |
| REPNE 串指令 | 不等重复。即当 CX≠0 且 ZF=0 时，重复串指令 |
| REPNZ 串指令 | 非零重复。条件和 REPNE 一样 |


1. 传送串指令

| 指令格式 | 指令功能 |
|-|-|
| MOVS 目标串地址,源串地址 | 根据源地址的类型传送字节、字或双字 |
| MOVSB | 一次传送一字节 |
| MOVSW | 一次传送一字 |
| MOVSD | 一次传送一双字，80386 及以后处理器支持 |

注意事项：<br>
(1) MOVSB、MOVSW、MOVSD 的目标串地址、源串地址采用默认值。<br>
(2) 源串地址的默认值是 DS:SI，目标串地址的默认值是 ES:DI。<br>
(3) 传送串指令不影响标志位。<br>

每次执行传送串指令后，变址寄存器会被处理器作相应的修改，以指向下一个要传送的字节、字或双字：<br>
(1) 增量修改地址(方向标志位 DF=0)。SI、DI 加 1(字节传送)、加 2(字传送)、加 4(双字传送)。其中 CLD 指令用于设置 DF=0。<br>
(2) 减量修改地址(方向标志位 DF=1)。SI、DI 减 1(字节传送)、减 2(字传送)、减 4(双字传送)。其中 STD 指令用于设置 DF=1。<br>


2. 比较串指令

> 比较串指令用于比较两个字符串或两个数据块。

| 指令格式 | 指令功能 |
|-|-|
| CMPS 目标串地址,源串地址 | 根据源地址的类型比较字节、字或双字 |
| CMPSB | 一次比较一字节 |
| CMPSW | 一次比较一字 |
| CMPSD | 一次比较一双字，80386 及以后处理器支持 |

注意事项：<br>
(1) CMPS 比较源串地址、目标地址对应的字节、字或双字，比较结果不送入目标串地址，而是反应在标志位上。<br>
(2) 与串传送指令一样，CMPSB、CMPSW、CMPSD 的目标串地址、源串地址采用默认值。
(3) 比较串指令影响标志位 AF、CF、OF、PF、SF、ZF。


3. 扫描串指令

| 指令格式 | 指令功能 |
|-|-|
| SCAS 目标串地址 | 根据目标地址的类型扫描字节、字或双字 |
| SCASB | 一次扫描一字节 |
| SCASW | 一次扫描一字 |
| SCASD | 一次扫描一双字，80386 及以后处理器支持 |

注意事项：<br>
(1) 执行扫描串指令前，待搜索内容送入寄存器 AL、AX 或 EAX。<br>
(2) SCAS 搜索目标串地址指向的单元。<br>
(3) SCASB 按 ES:DI 指向单元搜索 AL 的字节数据。<br>
(4) SCASW 按 ES:DI 指向单元搜索 AX 的字数据。<br>
(5) SCASD 按 ES:DI 指向单元搜索 EAX 的双字数据。<br>

搜索的方法是————用 AL、AX 或 EAX 的数据减去搜索地址指向的字节、字或双字，差值影响标志位，通过标志位获知搜索结果。若差值为 0，即 ZF=1，那么搜到了指定字符；若差值不为 0，即 ZF=0，则未搜到指定字符。


4. 装入串指令

| 指令格式 | 指令功能 |
|-|-|
| LODS 源串地址 | 根据源地址的类型装入字节、字或双字 |
| LODSB | 一次装入一字节 |
| LODSW | 一次装入一字 |
| LODSD | 一次装入一双字，80386 及以后处理器支持 |

注意事项：<br>
(1) 装入串指令将源串地址指向的字节、字或双字装入累加器 AL、AX 或 EAX，之后根据方向标志 DF 确定对指针寄存器 SI 增 1 或 减 1(装入字节)、增 2 或 减 2(装入字)、增 4 或 减 4(装入双字)，以指向下一个要装入的字节、字或双字。<br>
(2) 装入串指令不影响标志位。<br>
(3) 装入串指令不需要重复前缀。<br>

```asm
; 功能相同的两段指令

; 段 1
cld
lodsb

; 段 2
mov al,[si]
inc si
```


5. 存储串指令

> 存储串指令与装入串指令的功能相反，是累加器数据存入存储单元。

| 指令格式 | 指令功能 |
|-|-|
| STOS 目标串地址 | 根据目标地址的类型存储字节、字或双字 |
| STOSB | 一次存储一字节 |
| STOSW | 一次存储一字 |
| STOSD | 一次存储一双字，80386 及以后处理器支持 |

注意事项：<br>
(1) 存储串指令把寄存器 AL、AX 或 EAX 的数据存入指针 ES:DI 指向的存储单元，之后根据标志位 DF 对寄存器 DI 增值或减值。<br>
(2) 存储串指令不影响标志位。<br>


6. 输入串指令

> 输入串指令用于从外设端口读入数据，并存入存储单元。

| 指令格式 | 指令功能 |
|-|-|
| INS 目标串地址 | 根据目标地址的类型输入字节、字或双字 |
| INSB | 一次输入一字节 |
| INSW | 一次输入一字 |
| INSD | 一次输入一双字，80286 及以后处理器支持 |

注意事项：<br>
(1) 输入串指令从指定端口接收一个串，存入一片连续的存储单元。<br>
(2) 输入端口由 DX 指定，存储单元的首地址由 ES:DI 指定，读入数据的个数由 CX 指定。<br>
(3) 每次执行指令后，根据标志位 DF 确定对寄存器 DI 增值或减值。<br>
(4) 输入串指令不影响标志位。<br>


7. 输出串指令

> 输出串指令用于输出串数据到指定的输出端口。

| 指令格式 | 指令功能 |
|-|-|
| OUTS 源串地址 | 根据源地址的类型输出字节、字或双字 |
| OUTSB | 一次输出一字节 |
| OUTSW | 一次输出一字 |
| OUTSD | 一次输出一双字，80286 及以后处理器支持 |

注意事项：<br>
(1) 输出端口由 DX 指定，串数据的首地址由 DS:SI 指定，输出数据的个数由 CX 指定。<br>
(2) 每次执行指令后，根据标志位 DF 确定对寄存器 DI 增值或减值。<br>
(3) 输出串指令不影响标志位。<br>


### 程序控制指令
> 程序控制指令用于控制程序的走向，实质是改变 CS、IP(或 EIP)，使处理器转去执行新地址指向的指令。程序控制指令包括 转移指令、循环控制指令、过程调用指令和过程返回指令、中断指令。除中断指令外，它们都不影响状态标志位。


1. 转移指令


1). 无条件转移指令

| 指令格式 | 指令功能 |
|-|-|
| JMP 标号 | 用于段内的直接转移 |
| JMP 寄存器/存储器的有效地址 | 用于段内的间接转移 |
| JMP FAR 标号 | 用于两段之间的直接转移 |

注意事项：<br>
(1) JMP 指令不影响标志位。<br>


2). 条件转移指令

> 条件转移指令一般情况下是结合 CMP 指令或 TEST 指令使用，根据前者对标志位的影响，从而判断代码接下来往何处执行。


2-1). 无符号数的条件转移指令

| 指令助记符 | 指令名称 | 转移条件 |
|-|-|-|
| JA/JNBE 标号 | 高于转移/不低于或等于转移 | CF=0 且 ZF=0 |
| JAE/JNB 标号 | 高于或等于转移/不低于转移 | CF=0 |
| JB/JNAE 标号 | 低于转移/不高于或等于转移 | CF=1 |
| JBE/JNA 标号 | 低于或等于转移/不高于转移 | CF=1 或 ZF=1 |


2-2). 有符号数的条件转移指令

| 指令助记符 | 指令名称 | 转移条件 |
|-|-|-|
| JG/JNLE 标号 | 大于转移/不小于或等于转移 | SF=OF 且 ZF=0 |
| JGE/JNL 标号 | 大于或等于转移/不小于转移 | SF=OF |
| JL/JNGE 标号 | 小于转移/不大于或等于转移 | SF≠OF 且 ZF=0 |
| JLE/JNG 标号 | 小于或等于转移/不大于转移 | SF≠OF 或 ZF=1 |


2-3). 特殊算术标志位的条件转移指令

| 指令助记符 | 指令名称 | 转移条件 |
|-|-|-|
| JNE/JNZ 标号 | 不等于转移/结果不是 0 转移 | ZF=0 |
| JC 标号 | 有进位(或有借位)转移 | CF=1 |
| JNC 标号 | 无进位(或无借位)转移 | CF=0 |
| JO 标号 | 溢出转移 | OF=1 |
| JNO 标号 | 无溢出转移 | OF=0 |
| JP/JPE 标号 | 1 的个数位偶数转移 | PF=1 |
| JNP/JPO 标号 | 1 的个数位奇数转移 | PF=0 |
| JS 标号 | 符号位是 1 (负数)转移 | SF=1 |
| JNS 标号 | 符号位是 0 (正s数)转移 | SF=0 |

注意事项：<br>
(1) 条件转移指令不影响标志位。<br>


2. 循环控制指令

> 循环指令用于构造循环程序。循环次数通常存入 CX 或 ECX 寄存器(计数器)。每循环一次，计数器减 1，若 CX≠0 或 ECX≠0，则循环继续；当 CX=0 或 ECX=0，则退出循环。除了用 CX 或 ECX 数据决定是否结束循环外，有的循环指令可以根据零标记 ZF 决定是否结束循环。循环指令本身不影响标志位。


1). 无条件循环指令

| 指令格式 | 指令特点 |
|-|-|
| LOOP 标号 | CX 作循环计数器 |
| LOOPW 标号 | CX 作循环计数器，80386 及以后处理器支持 |
| LOOPD 标号 | ECX 作循环计数器，80386 及以后处理器支持 |


2). 条件循环指令


2-1). 相等或是零的循环指令

| 指令格式 | 指令特点 |
|-|-|
| LOOPE/LOOPZ 标号 | CX 作循环计数器 |
| LOOPEW/LOOPZW 标号 | CX 作循环计数器，80386 及以后处理器支持 |
| LOOPED/LOOPZD 标号 | ECX 作循环计数器，80386 及以后处理器支持 |

指令功能是：每循环一次，CX-- 或 ECX--。若 CX≠0 或是 ECX≠0 且 ZF=1，则转向标号指向的指令；若循环计数器=0 或 ZF=0，则终止循环。

2-2). 不等或不是零的循环指令

| 指令格式 | 指令特点 |
|-|-|
| LOOPNE/LOOPNZ 标号 | CX 作循环计数器 |
| LOOPNEW/LOOPNZW 标号 | CX 作循环计数器，80386 及以后处理器支持 |
| LOOPNED/LOOPNZD 标号 | ECX 作循环计数器，80386 及以后处理器支持 |

指令功能是：每循环一次，CX-- 或 ECX--。若 CX≠0 或是 ECX≠0 且 ZF=0，则转向标号指向的指令；若循环计数器=0 或 ZF=1，则终止循环。


3. 过程调用指令和过程返回指令

> 过程调用指令与过程返回指令是互逆操作，一个用于去，一个用于回。


1). 过程调用指令 **CALL**

指令格式：

`CALL 过程名/寄存器/过程的首地址`

过程调用的执行过程如下：<br>
(1) 保护断点地址(CALL 指令下一条指令的偏移地址存入栈)。<br>
(2) 获取过程的开始地址(过程的第 1 条指令的偏移地址)。<br>
(3) 执行过程。<br>
(4) 过程结束后，返回原调用处(CALL 指令的下一条指令)继续执行(断点恢复)。<br>

这个表格？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？
| 指令格式 | 指令解释 |
|-|-|
| CALL tag | 直接近调用，直接给出过程名 tag |
| CALL FAR tag | 直接远调用，tag 是远过程 |
| CALL BX | 间接近调用，BX 寄存器给出过程第 1 条指令的偏移地址 |
| CALL WORD [tag] | 间接近调用，字单元 tag 存放过程第 1 条指令的偏移地址 |
| CALL WORD [BX] | 间接近调用，BX 所指的字单元存放过程第 1 条指令的偏移地址 |
| CALL DWORD [BX] | 间接远调用，BX 所指的双字单元存放过程第 1 条指令的偏移地址和段的基地址 |

注意事项：<br>
(1) 执行近调用时，首先把 CALL 指令的下一条指令的偏移地址(IP 或 EIP)存入栈中保护。然后把被调用过程的第 1 条指令的偏移地址送给 IP 或 EIP。接着便转去执行 IP 或 EIP 指向的指令。<br>
(2) 执行远调用时，不仅把 CALL 指令指向的下一条指令的偏移地址(IP 或 EIP)存入栈，段寄存器 CS 的数据也要存入栈。被调用过程第 1 条指令的偏移地址和段的基地址分别送给 IP (或 EIP) 和 CS，然后转去执行 CS:IP (或 CS:EIP)指向的指令。<br>


2). 过程返回指令 **RET**

指令格式：

`RET [常数]`

注意事项：<br>
(1) 若返回指令后面给出常数(通常是偶数)，则有 "SP+常数 -> SP"。<br>
(2) 过程调用指令本身不影响标志位，过程中的指令会改变标志位。若需要保留过程之前的标志位，在过程开始时应把标志位存入栈中保存，指令过程返回指令之前再恢复标志位。<br>


4. 中断指令

> 所谓中断是处理器暂停当前正在执行的程序，转去处理已发生的随机事件，处理完成后(执行处理随机事件的程序)再返回到被中止的程序继续执行。

注意事项：<br>
(1) 中断分为硬件中断(外部中断)、软件中断(内部中断)。<br>
(2) 中断指令用于产生软件中断，执行已编好的中断服务程序(也叫中断处理程序)。<br>


1). 软件中断指令 **INT**

指令格式：

`INT 中断类型码`

注意事项：<br>
(1) 中断类型码也叫中断向量码，是 0~255 的整数，如 INT 33 是执行 33 号中断服务程序。<br>
(2) 处理器根据中断类型码可以获得中断服务程序的存储位置，中止当前正在执行的程序，转去执行中断服务程序，执行完后再继续执行被中止的程序。<br>


2). 中断返回指令 **IRET** 或 **IRETD**

注意事项：<br>
(1) 中断返回指令没有操作数。<br>
(2) IRETD 是 80386 及以后处理器新增的指令。<br>
(3) 该指令的功能是————执行中断服务程序后，返回到被中止的程序继续执行。<br>


### 处理器控制指令


1. 暂停指令 **HLT**

指令格式：

`HLT`

注意事项：<br>
(1) HLT 指令用于暂停处理器的工作，处于等待状态，当外部中断后结束暂停状态，继续执行 HLT 后面的指令。<br>
(2) HLT 指令不影响标志位。<br>


2. 空操作指令 **NOP**

指令格式：

`NOP`

注意事项：<br>
(1) NOP 指令用于完成一次空操作，除了修改指令指针寄存器(IP)外，不做任何操作。<br>
(2) NOP 指令占用 3 个时钟周期。<br>
(3) 使用 NOP 指令，可推迟下一条指令的执行，延长程序的执行时间。<br>


