## C 语言的语法特点

C 语言的关键字只有 32 个：
* auto: 声明自动变量。
* short: 声明短整型变量或函数。
* int: 声明整型变量或函数。
* long: 声明长整型变量或函数。
* float: 声明浮点型变量或函数。
* double: 声明双精度变量或函数。
* char: 声明字符型变量或函数。
* struct: 声明结构体变量或函数。
* union: 声明共用数据类型。
* enum: 声明枚举类型。
* typedef: 用以为数据类型取别名。
* const: 声明只读变量。
* unsigned: 声明无符号类型变量或函数。
* signed: 声明有符号类型变量或函数。
* extern: 声明变量是在其他文件中声明的。
* register: 声明寄存器变量。
* static: 声明静态变量。
* volatile: 声明变量在程序中可被隐含地改变。
* void: 声明函数无返回值或无参数，声明无类型指针。
* if: 条件语句。
* else: 条件语句否定分支(与 if 连用)。
* switch: 用于开关语句。
* case: 开关语句分支。
* for: 一种循环语句。
* do: 循环语句的循环体。
* while: 循环语句的循环条件。
* goto: 无条件跳转语句。
* continue: 结束当前循环，开始下一轮循环。
* break: 跳出当前循环。
* default: 开关语句中的"其他"分支。
* sizeof: 计算数据类型长度。
* return: 子程序返回语句(可以带参数或不带)循环条件。


## AT&T 汇编基础

AT&T 汇编语法的特点如下：
* 程序源文件一般以 ".s" 作为文件名后缀，以 "#" 开头表示注释。
* 寄存器名以 "%" 作为前缀。
* 立即操作数以 "$" 前缀表示。
* 目标操作数在源操作数的右边。
* 操作数的字长由操作符的最后一个字母决定，后缀 "b"、"w"、"l" 分别表示操作数为字节(byte, 8 bite)、字(word, 16 bite)、长字(long, 32 bite)。
* 远程转移指令和远程子调用指令的操作码分别为 ljump 和 lcall 。

```s
# 将立即数 1 复制到 eax 所指向的内存中
# eax 用括号包围，表示操作数在 eax 指向的内存中
movl $1,(%eax)

# 32 位操作
# 将寄存器 eax 的内容复制到 ebx 中
movl %eax,%ebx

# 16 位操作
# 将寄存器 ax 的内容复制到 bx 中
movw %ax,%bx

# 8 位操作
# 将寄存器 al 的内容复制到 bl 中
movb %al,%bl

# 32 位 ecx 的内容入栈
pushl %ecx

# 16 位 cx 的内容入栈
pushw %cx

# 180 作为一个 32 位整数入栈
pushl $180

# data 变量内容入栈，长度为 32 位
pushl data

# data 变量地址入栈
# 在变量的前面加上 $ 前缀表示获取地址
pushl $data

# Unix 系统下模拟 C 语句的 return 0;
# 即调用第 0x80 号软中断执行 1 号功能
pushl $0          # 参1: 退出代码
movl $1,%eax      # 系统调用号 (sys_write)
int $0x80         # 调用内核功能

# Linux 系统下模拟 C 语句的 return 0;
# 即调用第 0x80 号软中断执行 1 号功能
movl $0,%ebx      # 参1: 退出代码
movl $1,%eax      # 系统调用号 (sys_write)
int $0x80         # 调用内核功能
```


## C 指针基础

C 指针的主要特点如下：
* 通过一个变量声明时在前面使用 "*" 号，表明这是个指针型变量，该变量存储了一个内存地址。
* 单目运算符 "*" (不是指代表乘法运算的双目运算符 * ) 是获取指向内容的操作符，用来获取内存地址里存储的内容。
* 单目运算符 "&" 是获取地址的操作符，用来获取变量的地址。


### 指向标量的 C 指针

标量是指仅含有单个值的变量，比如整型(int)、长整型(long)、浮点型(float) 等普通类型(包括指针类型)的变量。

例如：

```c
#include <stdio.h>
int main(void) {
  // 定义标量 x
  int x;
  x = 128;

  // x_p 指向标量 x 的地址
  int *x_p = &x;

  // x_p_p 指向标量 x_p 的地址
  int **x_p_p = &x_p;

  return 0;
}
```


### 多维数组名代表指针

若不用下标，则可以直接引用多维数组名代表指针变量，它是一个指向最后一维长度的数组的指针。假设 x 是一个 2 × 5 的数组，即 `int x[2][5];` 。可以不使用任何下标直接引用 x，此时 x 代表指向一个包括 5 个元素的数组的指针，每次将 x 增加或减数 1，都表示向前移动或向后移动 5 个元素。

```c
#include <stdio.h>
int main(void) {
  int x[2][5] = {
    { 1, 2, 3, 4, 5 },
    { 6, 7, 8, 9, 10 }
  };
  int i, j;
  for (i = 0; i < 2; i++) {
    for (j = 0; j < 5; j++) {
      printf("%d ", *(*(x + i) + j));
    }
  }
  return 0;
}

// -> 1 2 3 4 5 6 7 8 9 10
```


### main 命令行参数

C 语言的 main 函数是主函数，也是程序执行的起点，它的参数通常有两个：第一个参数是 argc，代表参数的个数；第二个参数是 argv，它是一个指向参数数组的指针，参数数组中的每个元素都是字符型的。因此 argv 声明为指向指针的指针。

新建文件 test.c 并输入以下内容：

```c
#include <stdio.h>
int main(int argc, char** argv) {
  printf("%d\n", argc);

  while (*++argv != NULL) {
    printf("%s\n", *argv);
  }

  return 0;
}
```

编译后，在命令行中执行 `./test -a 12 24` 。输出如下：

```
4
-a 12 24
```

之所以输出 4，是因为 ./test 命令本身也算上了参数的个数。


### const 指针

const 类型定义的指针表示它指向的变量或对象的值是不能修改的。const 指针主要分为 3 类。


1. 指针指向的内容不可变，但指针本身可以改变。声明方式：

```c
const int* a;
int const* a;
```

也就是说，我们可以执行 `a++;`，但无法执行 `(*a)++;`。


2. 指针本身不能变，但指向的内容可以修改。声明方式：

```c
int* const a;
```

也就是说，我们可以执行 `(*a)++;`，但无法执行 `a++;`。


3. 指针本身不能改变，指向的内容也不能改变

```c
const int* const a;
int const* const a;
```

实际上，变量 **a** 在声明时就必须赋值，然后，我们既无法执行 `(*a)++;`，也无法执行 `a++;`。另外，该功能主要用于接口设计，目的是为了告诉调用者：我们既不会修改指针，也不会修改指针指向的值。


### 函数指针

我们可以定义指针指向函数，存储函数的起始地址。声明格式：

`返回类型 (*函数指针变量名)(参数列表);`

例如，我们可以通过 fn 函数直接调用 add 函数。fn 指针仿佛成了 add 函数的别名：

```c
#include <stdio.h>

int add(int a, int b);

int main(void) {
  int (*fn)(int a, int b);
  fn = add;
  int x = fn(12, 36);
  printf("%d\n", x);
  return 0;
}

int add(int a, int b) {
  return a + b;
}
```

利用函数指针机制，能让 C语言 模仿 C++ 的类，实现某种程度的面向对象编程：

```c
#include <stdio.h>

struct Object {
  int a;
  int b;
  int result;
  void (*mod_add)(int a, int b, int* result);
};

void m_add(int a, int b, int* result) {
  (*result) = (a + b) % 13;
}

int main(void) {
  struct Object obj;
  obj.a = 12;
  obj.b = 26;
  obj.mod_add = m_add;

  obj.mod_add(obj.a, obj.b, &obj.result);
  printf("%d\n", obj.result); // -> 12
  return 0;
}
```


### 函数指针数组

函数指针数组是以某数组元素为指针，这些指针均指向函数的起始地址。这样做的好处是：可以先定义若干函数，然后将这些函数的起始地址放入指针数组中，这样就可以通过指针数组中的元素来调用相关的函数执行。定义方法：

`返回类型 (*函数指针变量名[])(参数列表);`


## 文件指针

C语言 通常用一个指针变量指向一个文件，该指针称为文件指针，通过文件指针就可以对它所指的文件进行各种操作。定义格式：

`FILE* 指针变量标识符;`

其中，FILE 为大写，它是由系统定义的一个结构，该结构含有文件名、文件状态和文件当前位置等信息。编写 C程序 时，不必知道这个结构的细节。


1. fopen 函数

该函数用于打开文件，文件顺利打开后，指向该流的文件指针将被返回。调用方式：

`文件指针名 = fopen(文件名, 使用文件方式);`

其中，使用文件的方式包括：
* "r" 只能从文件中读数据，该文件必须先存在，否则打开会失败。
* "w" 只能向文件写数据，若指定的文件不存在则创建它，如果存在则先删除它然后再重建一个新文件。
* "a" 向文件增加新数据(不删除原有数据)，若文件不存在则打开失败，打开时位置指针将移到文件末尾。
* "r+" 可读/写数据，该文件必须先存在，否则打开会失败。
* "w+" 可读/写数据，用该模式打开一个新建文件，先向该文件写数据，然后就可读取该文件中的数据。
* "a+" 可读/写数据，原来的文件不被删去，位置指针移到文件末尾。

此外，打开二进制文件的模式与打开文本文件的含义类似，但需要在使用文件方式前加上字母 'b'，以表示以二进制形式打开文件，比如，'wb' 表示以二进制方式写入文件。


2. fclose 函数

该函数可用于关闭文件流，并释放文件指针和相关的缓冲区。如果是以可写方式打开文件，则该函数会将缓冲区内剩余的数据输出到磁盘文件中。调用方式：

`fclose(文件指针名);`


3. fgets 函数

该函数从文件指针中读取数据，每次读取一行，读取的数据保存在字符指针指向的字符缓冲区中，每次最多读取(缓冲区大小 - 1)个字符，最后一个字符是字符串的结束符 "\0"，函数执行成功将返回缓冲区指针，若失败或读到文件结尾则返回 NULL。调用方式：

`fgets(指向字符缓冲区首地址的字符指针, 字符缓冲区大小, 文件指针名);`


4. fgetc 函数

该函数从文件指针指向的文件中读取一个字符，读取一个字节后，文件的位置指针(定位当前文件的内部位置)后移一个字节。fgetc 返回读取到的字符，若返回 EOF 则表示到了文件结尾，或者出现了错误。调用方式：

`fgetc(文件指针名);`


5. fputs 函数

该函数向指定的文件写入一个字符串(不自动写入字符串结束标记符 '\0')，成功写入后，文件的位置指针会自动后移，函数返回为一个非负整数，否则返回返回 EOF。调用方式：

`fputs(字符串缓冲区首地址, 文件指针名);`


6. fputc 函数

该函数将字符写到文件指针所指向的文件的当前写指针的位置，当正确写入一个字符或一个字节的数据后，文件内部写指针会自动后移一个字节的位置。调用方式：

`fputc(字符, 文件指针名);`


### GCC 编译与优化

使用 GCC 编译 C语言 源代码文件并生成可执行文件，一般可分为四个阶段：<br>
1) 预处理阶段: GCC 首先调用 cpp 进行预处理，在此过程中，对源代码文件中的文件保护(include)、预编译语句(如宏定义 define 等)进行分析。<br>
2) 编译阶段: 调用 ccl 进行编译，这个阶段将根据输入文件生成以 ".o" 为后缀的目标文件。<br>
3) 汇编阶段: 针对汇编语言调用 as 进行工作，一般来讲，汇编语言源代码文件经过预编译和汇编之后都会生成以 ".o" 为后缀的目标文件。<br>
4) 链接阶段：将所有的目标文件都安排在可执行程序中的恰当位置，同时，把程序调用到的库函数从各自所在的档案库中连接到程序中合适的地方。<br>

> 注: GCC 编译 C 代码会尝试用最少的时间完成编译(这样的生成代码易于调试，但没经过优化)。在编译选项中，"-o" 选项表示对源代码进行基本优化；"-o2" 选项则告诉 GCC 产生尽可能小的和尽可能快的代码(这需要耗费更多的编译时间)。


### GDB 调试

使用 GDB 调试前，需要先生成调试信息，例如：

`gcc -ggdb -std=c99 -o hello hello.c`

然后，就可以开始调试了：

`gdb test`

其他有关于 GDB 的使用命令，请到网上搜索。


### make 工具

make 是一个工具程序，可读取称为 "makefile" 的文件，并自动构建软件。makefile 的格式为：

```
# 用 "#" 号表明注释
target(表示要生成的文件): dependencies(表示被依赖的文件)
	# 要明白: 命令前面用的是 "tab" 而不是空格。
	# 误用空格是初学者最容易犯的错误！
	# 另外，target 之间的顺序并不重要！
	命令 1
	命令 2
	命令 3
	.
	命令 n
# 可以使用 "\" 表示续行。注意，"\" 之后不能有空格！
```

如果直接在命令行执行 `make` ，则带有 dependencies 的 target 会被自动执行(根据它们的依赖关系自动确定执行顺序)，反之，则被当作命令而不会执行。

> target 通常是我们要生成的文件的名字，其中第一个 target 是默认的 target。即当 make 不带参数时，自动执行并得到第一个 target。另外，target 也可以是要求 make 完成的动作，执行这种 target 之后并不能得到与 target 同名的文件，因此，也被称为伪 target (phony target)。

如果不想使用默认的 "makefile" 文件名作为 makefile。也可以手动指定：

`make -f 被当作makefile的文件名`


### make 依赖关系

该检查系统非常简单，主要是根据依赖文件的修改时间进行判断，如果修改时间比编译时的时间要新，那么才会重新编译，否则不会重新编译；如果需要调用 make 强行进行重新编译，就需要将编译后的目标文件删除。


### makefile 变量

在 makefile 文件中可以使用变量，使用 "变量名 = 值" 的格式进行定义。定义变量后，可以使用 "$(变量名)" 的方式进行引用。例如：

```
my_target = test
$(my_target): test.c
	gcc 5-2.c -o $(my_target)
```


## 内存管理

glibc 实现了 malloc，它实现了 Linux 系统的堆管理，在 Linux 中没有专有的所谓的 API，所有的调用几乎都以 C库 为根本，因此 glibc 显得尤为重要(glibc 与 Windows 的实现是一样的)。


### calloc、malloc 和 realloc 函数

调用 calloc、malloc、realloc 函数可以申请分配内存空间，但如果要连续调用它们，则不能保证空间是顺序或连续的。分配成功后，函数将返回一个指针，这个指针将指向分配成功的空间位置，它可以指向任意类型的对象；若空间分配失败，则返回 NULL 指针。当内存不再使用时，应使用 free() 函数释放内存块。

1) calloc

calloc 函数为 nmemb 个对象的数组分配空间，每个元素的大小为 size，分配的空间所有位均被初始化为 0。原型如下：

```c
void *calloc(size_t nmemb, size_t size);
```

2) malloc

malloc 函数分配长度为 size 字节的内存块. malloc 函数是内存分配的核心。realloc 函数和 calloc 函数均在内部调用 malloc 函数申请更大的内存空间和申请空间并初始化为 0。原型如下：

```c
void *malloc(size_t size);
```

3) realloc

realloc 函数改变 ptr 所指内存区域的大小为 size 长度。新分配空间比原空间大，并且包括了原空间的内容，但因为分配新空间，没有了初始化 0 的操作，所以新空间中除去旧空间的部分的内容不能保证清空为零。原型如下：

```c
void *realloc(void *ptr, size_t size);
```


### free 函数

通过 calloc、malloc、realloc 函数分配的空间可以通过 free 函数释放。free 函数释放指针 ptr 所指向的内存空间。ptr 所指向的内存空间必须是用 calloc、malloc、realloc 函数分配的空间。如果 ptr 为 NULL，或者指向不存在的内存块，则不做任何操作，释放的空间还可以被重新分配。原型如下：

```c
extern void free(void *ptr);
```


## 编译信息的预定义宏

这些宏用于反映编译信息。


### __FILE__ 和 __LINE__

`__FILE__` 用于指示本行语句所在源文件的文件名。

`__LINE__` 用于指示本行语句的行号信息。

新建一个文件 **test.c**

```c
#include <stdio.h>
void main(void) {
  printf("Hello World!\n");
  printf("%s\n", __FILE__);
  printf("%d\n", __LINE__);
}
```

输出的内容为：

```c
// Hello World!
// var_grand.c
// 5
```


### #line 和 #error

C语言 可以用 #error 表示停止编译，显示错误信息，还可以用 #line 直接指定**下一行**的行号及文件名(影响波及后面所有的语句)。其中，#line 包含如下两种定义方式：

1) 指定行号

```c
#line n
```

2) 指定文件名和行号

```c
#line n "filename"
```

我们先新建文件 **first.c**

```c
#line 4 "second.c"
#define LINUX
#ifdef WIN32
  printf("win32\n");
#elif defined LINUX
  printf("linux %d %s\n", __LINE__, __FILE__);
#else
  #error no flag define
  /**
   * 如果 Linux 和 win32 都没有定义，
   * 则 #error 会显示错误信息，然后停止编译
   */
#endif
```

然后在同一目录下创建另一个文件 **second.c**

```c
#line 1
#include <stdio.h>
int main(void) {
  printf("line 1\n");
  printf("line 2\n");
  printf("line 3\n");
  #include "first.c"
}
```

最终输出的结果为：

```c
// line 1
// line 2
// line 3
// linux 8 second.c
```

